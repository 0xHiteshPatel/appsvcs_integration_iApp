cli admin-partitions {
    update-partition Common
}
sys application template /Common/appsvcs_integration_v0.3_004 {
    actions {
        definition {
            html-help {
            }
            implementation {
#
# This Source Code Form is subject to the terms of the Mozilla Public
# License, v. 2.0. If a copy of the MPL was not distributed with this
# file, You can obtain one at http://mozilla.org/MPL/2.0/.

set startTime [clock seconds]
set NAME "F5 Application Services Integration iApp (Community Edition)"
set IMPLVERSION "0.3(006)"
set PRESVERSION "004"

proc custom_extensions {} {
  # ####################################################################
  # Custom config example
  # The purpose of the extensions__fieldX fields are to allow for changes WITHOUT updates
  # to the APIC device package.  By exposing these fields now we can add code to the implementation
  # portion of the iApp to handle new functionality.  Example 1 parses a string of the
  # format "key1=val1;key2=val2;key3=val3" and populates variables that can be acted on.
  #
  # Another use case is to use the field to pass raw commands to the tmsh::create command as in Example 2 below
  #
  # Example 1
  set pairs [split $::extensions__Field1 \;]
  debug "\[custom_extentions\] Custom1: pairs=$pairs"
  array set custom_kvp {}
  foreach pair $pairs {
   set key [lindex [split $pair =] 0]
   set val [lindex [split $pair =] 1]
   set custom_kvp($key) $val
   debug "\[custom_extentions\] Custom1: pair=$pair key=$key val=$val custom_kvp($key)=$custom_kvp($key)"
  }
  
  if { [info exists custom_kvp(nagle)] && $custom_kvp(nagle) == 0 } {
  debug "\[custom_extentions\] This is an example of the custom KVP nagle=0 in Custom String 1"
  }
  
  if { [info exists custom_kvp(logit)] && $custom_kvp(logit) == 1} {
   debug "\[custom_extentions\] This is an example of the custom KVP logit=1 in Custom String 1"
  }
  
  # Example 2 
  # Populate String 2 with a valid command like:
  #  ltm data-group internal customDG type string records replace-all-with { record1 { data data1 } record2 { data data2 } }
  #
  # Once the template executes you can see the creation of the datagroup under the application template container
  # tmsh::create $::extensions__Field2
  #
  # End custom config example
  # ####################################################################
}

# Print a timestamped debug message to /var/tmp/scriptd.out
# Input: string
proc debug { string } {
  set systemTime [clock seconds]
  puts "\[[clock format $systemTime -format %D]\]\[[clock format $systemTime -format %H:%M:%S]\]\[$tmsh::app_name\] $string"
}

# Figure out which type of environment we are executing in.
# Return: list $mode $folder $partition $routedomainid
# Modes: 1 = Standalone
#        2 = BIG-IQ Cloud
#        3 = Cisco APIC
proc get_mode { } {
  set folder [tmsh::pwd]
  set partition [lindex [split $folder /] 1]
  set routedomainid 0
  debug "\[get_mode\] starting folder=$folder partition=$partition routedomainid=$routedomainid"
  
  # Check for a partition that starts with apic_ and return APIC mode (2) and RD if found
  if { [string match -nocase "apic_*" $partition] } {
    debug "\[get_mode\]\[apic\] partition starts with apic_, assuming APIC deployment mode (3)"
    set rdobjs [tmsh::get_config net route-domain "/$partition/$partition" id]
    set routedomainid [tmsh::get_field_value [lindex $rdobjs 0] "id"]
    debug "\[get_mode\]\[apic\] rdobjs=$rdobjs routedomainid=$routedomainid"
    return [list 3 $folder $partition $routedomainid]
  }

  # If we get here we can safely assume that this is either a Standalone or BIG-IQ Cloud mode deployment
  # The only way we currently have to check for BIG-IQ Cloud mode is to see if app_stats was sent
  if { [info exists ::app_stats] } {
    debug "\[get_mode\]\[bigiq\] all other modes checked for and app_stats set, assuming BIG-IQ Cloud deployment mode (2)"
    return [list 2 $folder $partition $routedomainid]
  }

  # Default is Standalone mode
  debug "\[get_mode\]\[standalone\] no integration vendor found, assuming Standalone deployment mode (1)"    
  return [list 1 $folder $partition $routedomainid]
}

# Create a specfic option command and return it
# Input: $debug_id, $input_var, $option_string
# Return: string $cmd
proc generic_add_option { debug_id input_var option_string custom_format replace_commas } {
  set cmd " "
  if { [string length $input_var] > 0 } {
      if { $replace_commas == 1 } {
        set input_var [string map {"," " "} $input_var]
      }

      if { [string length $custom_format] > 0 } {
        set cmd [format $custom_format $input_var]
      } else {
        set cmd [format " $option_string \"%s\"" $input_var]
      }
      debug [format "\[%s\]\[generic_add_option\] cmd=%s" $debug_id $cmd]
  }
  return $cmd
}

# Check to see if an ip has a routedomain included.
# Return: 0=false; 1=true
proc has_routedomain { ip } {
  return [string match *%* $ip]
}

set app $tmsh::app_name
debug "Starting $NAME version IMPL=$IMPLVERSION PRES=$PRESVERSION app_name=$app"

set modeinfo [get_mode]
set mode [lindex $modeinfo 0]
set folder [lindex $modeinfo 1]
set partition [lindex $modeinfo 2]
set rd [lindex $modeinfo 3]

debug "\[modeinfo\] mode=$mode folder=$folder partition=$partition rd=$rd"

# Define various global values
set allVars {
 iapp__strictUpdates \
 iapp__appStats \
 vs__Name \
 vs__IpProtocol \
 vs__ConnectionLimit \
 vs__Description \
 vs__SourceAddress \
 pool__addr \
 pool__mask \
 pool__port \
 vs__ProfileClientProtocol \
 vs__ProfileServerProtocol \
 vs__ProfileHTTP \
 vs__ProfileOneConnect \
 vs__ProfileDefaultPersist \
 vs__ProfileFallbackPersist \
 vs__SNATConfig \
 vs__ProfileClientSSL \
 vs__ProfileClientSSLCert \
 vs__ProfileClientSSLKey \
 vs__ProfileClientSSLChain \
 vs__ProfileClientSSLCipherString \
 vs__OptionSourcePort \
 vs__OptionConnectionMirroring \
 vs__Irules \
 feature__redirectToHTTPS \
 feature__securityEnableHSTS \
 pool__Name \
 pool__Description \
 pool__Monitor \
 pool__LbMethod \
 pool__MemberDefaultPort \
 pool__Members \
 extensions__Field1 \
 extensions__Field2 \
 extensions__Field3 \
 app_stats }

array set table_defaults {
    Members {
        State enabled
        IPAddress Error
        Port 80
        ConnectionLimit 0
        Ratio 1
    }
}
array set pool_state {
    enabled        {session user-enabled state user-up}
    disabled       {state user-down}
    force-disabled {state user-down}
    drain-disabled {session user-disabled state user-up}
}

# iRules used for feature__securityEnableHSTS
set irule_HSTS {  
when HTTP_RESPONSE {
  HTTP::header insert Strict-Transport-Security "max-age=31536000"
}
}; # end irule_HSTS

set irule_HSTS_redirect {  
when HTTP_REQUEST {
  HTTP::respond 301 Location "https://[getfield [HTTP::host] ":" 1][HTTP::uri]"
}
}; # end irule_HSTS_redirect
# end iRules used for feature__securityEnableHSTS

# Fixup incoming variables: If no value is sent for a particular iApp field than the var is not created which
# results in all sorts of problems.  We just check for existence of the var and set to "" if it doesn't exist
foreach var $allVars {
  if {[info exists [subst $var]]} {
    debug "\[input\] $var sent, value is: [set [subst $var]]"
  } else {
    set [subst $var] ""
    debug "\[input\] $var NOT sent, setting to blank"
  }
}

# Special handling for the Source Address because it comes in as 0.0.0.0/0 and
# needs to be 0.0.0.0%xxxx/0, where '%xxxx' is the route-domain ID
set working $vs__SourceAddress
debug "\[fix_src_addr\] Check if vs__SourceAddress needs to be fixed"
if { [string length $working] > 0 } {
  debug "\[fix_src_addr\]  Fixing vs__SourceAddress: orig=$working"
  set net  [lindex [split $working /] 0]
  set cidr [lindex [split $working /] 1]
  set vs__SourceAddress "$net%$rd\/$cidr"
  debug "\[fix_src_addr\]  new=$vs__SourceAddress"
}

# Create Client-SSL profile if Cert and Key are specified but ClientSSLProfile is not
debug "\[proc_client_ssl\] checking if client ssl cert & key were entered"
set clientssl 0
if { [string length $vs__ProfileClientSSLKey] > 0 && [string length $vs__ProfileClientSSLCert] > 0 && [string length $vs__ProfileClientSSL] == 0 } {
  tmsh::get_config /sys file ssl-key $vs__ProfileClientSSLKey
  tmsh::get_config /sys file ssl-cert $vs__ProfileClientSSLCert
  debug "\[create_client_ssl\]  ssl cert & key found... creating profile"

  set cmd [format "ltm profile client-ssl %s_clientssl key %s cert %s" $app $vs__ProfileClientSSLKey $vs__ProfileClientSSLCert]

  if { [string length $vs__ProfileClientSSLChain] > 0 } {
      tmsh::get_config /sys file ssl-cert $vs__ProfileClientSSLChain
      debug "\[create_client_ssl\]  adding cert chain"
      append cmd [format " chain %s" $vs__ProfileClientSSLChain]
  }

  if { [string length $vs__ProfileClientSSLCipherString] > 0 } {
      debug "\[create_client_ssl\]  adding cipher string"
      append cmd [format " ciphers \"%s\"" $vs__ProfileClientSSLCipherString]
  }

  debug "\[create_client_ssl\]  TMSH CREATE: $cmd"
  tmsh::create $cmd
  set clientssl 1
} else { 
  if { [string length $vs__ProfileClientSSL] > 0 } {
    debug "\[proc_client_ssl\] ClientSSLProfile was provided... checking if it exists"
    tmsh::get_config /ltm profile client-ssl $vs__ProfileClientSSL
    set clientssl 2
  } else {
    set clientssl 0
    debug "\[proc_client_ssl\] ssl cert & key not specified... skipped Client-SSL profile creation"
  }
}


# Create pool

# Check to see if a poolName was specified... if not set to $app_pool
if { [string length $pool__Name] == 0 } {
    set pool__Name [format "%s_pool" $app]
    debug "\[create_pool\] no poolName specified... setting to $pool__Name"
}

debug "\[create_pool\] name=$pool__Name"


# Setup the members portion of the command my processing the pool__Members APL table
set nummembers [llength $pool__Members]
set numcolumns [llength [lindex [lindex $pool__Members 0] 0]]

if { $nummembers == 0 } {
  set memberstr " members none "
  debug "\[create_pool\]\[member_str\] No pool members found... setting to none"
} else {
  set memberstr "members replace-all-with \{ "
  debug "\[create_pool\]\[member_str\] Checking pool table... nummembers=$nummembers numcolumns=$numcolumns"
  foreach row $pool__Members {
    debug "\[create_pool\]\[member_str\]  row=$row"
    array set column_defaults [subst $::table_defaults(Members)]
    array unset column

    # extract the iApp table data - borrowed from f5.lbaas.tmpl
    foreach column_data [lrange [split [join $row] "\n"] 1 end-1] {
        set name [lindex $column_data 0]
        set column($name) [lrange $column_data 1 end]
        #debug [format "column_data name=%s val=%s" $name $column($name)]
    }

    # fill in any empty table values - borrowed from f5.lbaas.tmpl
    foreach name [array names column_defaults] {
        if { ![info exists column($name)] || $column($name) eq "" } {
            set column($name) $column_defaults($name)
            debug "\[create_pool\]\[member_str\]  value for $name not found... setting to default of $column_defaults($name)"
        }
    }

    set ip $column(IPAddress)
    set port $column(Port)
    set connlimit $column(ConnectionLimit)
    set state $column(State)
    set ratio $column(Ratio)
    
    # Add a route domain if it wasn't included
    if {![has_routedomain $ip]} {
      set ip "$ip%$rd"
    }

    # TODO: Is this still required?
    # Sometimes we receive a transposed ip/port from BIG-IQ... fix it here
    if {[has_routedomain $port]} {
      set port $column(IPAddress)
      set ip $column(Port)
      debug "\[create_pool\]\[member_str\]  fixing ip=$ip port=$port"
    }
    debug "\[create_pool\]\[member_str\]  ip=$ip port=$port connlimit=$connlimit ratio=$ratio state=$state"
    
    # If we don't get a port in the pool member table than use the template value for pool__MemberDefaultPort
    if { [string length $port] == 0} {
      if { [string length $pool__MemberDefaultPort] == 0 } {
        debug "\[create_pool\]\[member_str\]  Pool member port was not specified, pool__MemberDefaultPort was blank, using pool__port=$pool__port"
        set port $pool__port
      } else {
        debug "\[create_pool\]\[member_str\]  Pool member port was not specified, using pool__MemberDefaultPort=$pool__MemberDefaultPort"
        set port $pool__MemberDefaultPort
      }
    }

    append memberstr [format " %s:%s \{ connection-limit %s ratio %s %s\} " $ip $port $connlimit $ratio $::pool_state($state)]
  }
  append memberstr " \} "
}
debug "\[create_pool\]\[member_str\]  memberstr=$memberstr"

# Setup the base pool create command
set cmd [format "ltm pool /%s/%s.app/%s %s " $partition $app $pool__Name $memberstr]

array set pool_options {
  "pool__LbMethod" "load-balancing-mode"
  "pool__Description" "description"
  "pool__Monitor" "monitor"
}

foreach {optionvar optioncmd} [array get pool_options] {
  #debug "\[create_pool\]\[options\] var=$optionvar cmd=$optioncmd"
  append cmd [generic_add_option "create_pool\]\[options" [set [subst $optionvar]] $optioncmd "" 0]
}

# Add the pool description
# if { [string length $pool__Description] > 0 } {
#     append cmd [format " description \"%s\"" $pool__Description]
# }

# # Add the pool monitor
# if { [string length $pool__Monitor] > 0 } {
#     append cmd [format " monitor %s" $pool__Monitor]
# }


debug "\[create_pool\] TMSH CREATE: $cmd"
tmsh::create $cmd

# Create virtual Server

# Process the 'auto' flag for feature__redirectToHTTPS
if { $feature__redirectToHTTPS eq "auto" && $pool__port eq "443" } {
  debug "\[create_virtual\]\[feature__redirectToHTTPS\] found auto flag and port is 443, setting feature to enabled"
  set feature__redirectToHTTPS enabled
}

# Check for HTTP Strict Transport Security (HSTS) option.  We do this here 
# so the irule can be easily appended to the existing iRule list
if { $clientssl > 0 && $feature__securityEnableHSTS eq "enabled"} {
  debug "\[create_virtual\]\[feature__securityEnableHSTS\] creating HSTS iRule"
  set hstsrule [format "/%s/%s.app/hsts_irule" $partition $app]
  set hstscmd "ltm rule $hstsrule $irule_HSTS"
  debug "\[create_virtual\]\[feature__securityEnableHSTS\] TMSH CREATE: $hstscmd"
  tmsh::create $hstscmd

  if { $feature__redirectToHTTPS eq "enabled"} {
    debug "\[create_virtual\]\[feature__securityEnableHSTS\] feature_redirectToHTTPS enabled, creating HSTS redirect iRule"
    set hstsredirectrule [format "/%s/%s.app/hsts_redirect_irule" $partition $app]
    set hstsredirectcmd "ltm rule $hstsredirectrule $irule_HSTS_redirect"
    debug "\[create_virtual\]\[feature__securityEnableHSTS\] TMSH CREATE: $hstsredirectcmd"
    tmsh::create $hstsredirectcmd
  }
  
  if { [string length $vs__Irules] > 0 } {
    debug "\[create_virtual\]\[feature__securityEnableHSTS\] vs__Irules has data, appending"
    append vs__Irules ",$hstsrule"
  } else {
    debug "\[create_virtual\]\[feature__securityEnableHSTS\] vs__Irules is empty, setting"
    set vs__Irules $hstsrule
  }
  debug "\[create_virtual\]\[feature__securityEnableHSTS\] vs__Irules=$vs__Irules"
}

# Check to see if a vsName was specified... if not set to $app_pool
if { [string length $vs__Name] == 0 } {
    set vs__Name [format "%s_vs" $app]
    debug "\[create_virtual\] no vsName specified... setting to $vs__Name"
}

set cmd [format "ltm virtual /%s/%s.app/%s " $partition $app $vs__Name]
debug "\[create_virtual\] base cmd=$cmd"

# Setup our listener destination address
if { ![has_routedomain $pool__addr]} {
  set vs_dest_addr "$pool__addr%$rd"
} else {
  set vs_dest_addr "$pool__addr"
}

# Keep vs_dest_addr as is for use by other features, create vs_dest with full <ip>%<rd>:<port> format
set vs_dest "$vs_dest_addr:$pool__port"

# Set virtual server options we support.  This array assumes a format " <option> <input value>" for the TMSH command.
array set vs_options {
 "pool__mask" "mask"
 "pool__Name" "pool"
 "vs_dest" "destination"
 "vs__IpProtocol" "ip-protocol"
 "vs__ConnectionLimit" "connection-limit"
 "vs__Description" "description"
 "vs__SourceAddress" "source"
 "vs__OptionSourcePort" "source-port"
 "vs__OptionConnectionMirroring" "mirror"
 "vs__ProfileFallbackPersist" "fallback-persistence"
}

# Set virtual server options we support.  This array allows specifcation of the specific TMSH command format
array set vs_options_custom {
 "vs__Irules" " rules \{ %s \}"
 "vs__ProfileDefaultPersist" " persist replace-all-with \{ %s \}"
}

# Process the vs_options array
foreach {optionvar optioncmd} [array get vs_options] {
  #debug "\[create_virtual\]\[options\] var=$optionvar cmd=$optioncmd"
  append cmd [generic_add_option "create_virtual\]\[options" [set [subst $optionvar]] $optioncmd "" 0]
}

# Process the vs_options_custom array
foreach {optionvar optioncmd} [array get vs_options_custom] {
  #debug "\[create_virtual\]\[options\] var=$optionvar cmd=$optioncmd"
  append cmd [generic_add_option "create_virtual\]\[options_custom" [set [subst $optionvar]] "" $optioncmd 1]
}

set snatcmd ""
# Add SNAT options
if { [string length $vs__SNATConfig] > 0 } {
  switch [string tolower $vs__SNATConfig] {
    automap { 
      append snatcmd " source-address-translation \{ type automap \}" 
    }
    partition-default { 
      append snatcmd [format " source-address-translation \{ pool /%s/%s type snat \}" $partition $partition] 
    }
    none { 
      append snatcmd " source-address-translation \{ type none \}" 
    }
    default {
          tmsh::get_config /ltm snatpool $vs__SNATConfig
          append snatcmd [format " source-address-translation \{ pool %s type snat \}" $vs__SNATConfig]
    }
  }
  debug "\[create_virtual\] adding snat cmd=$snatcmd"
}
append cmd $snatcmd

# Add profiles
set vsprofiles " profiles replace-all-with  \{ "
debug "\[create_virtual\] adding base vsprofiles=$vsprofiles"

# We have to specify context aware profiles first
# Figure out the correct context to apply protocol profiles
set clientContext "all"
set serverContext "all"

if { [string length $vs__ProfileClientProtocol] > 0 && [string length $vs__ProfileServerProtocol] > 0 && $vs__ProfileClientProtocol ne $vs__ProfileServerProtocol } {
  debug "\[create_virtual\]\[proto_profiles\] got both client and server protocol profiles"
  set clientContext "clientside"
  set serverContext "serverside"
} 

# Client-side protocol
if { [string length $vs__ProfileClientProtocol] > 0 } {
  append vsprofiles [format " %s \{ context %s \}" $vs__ProfileClientProtocol $clientContext]
  debug "\[create_virtual\]\[proto_profiles\] clientside protocol name=$vs__ProfileClientProtocol context=$clientContext"
}

# Server-side protocol
if { [string length $vs__ProfileServerProtocol] > 0 && $vs__ProfileClientProtocol ne $vs__ProfileServerProtocol } {
  append vsprofiles [format " %s \{ context %s \}" $vs__ProfileServerProtocol $serverContext]
  debug "\[create_virtual\]\[proto_profiles\] serverside protocol name=$vs__ProfileServerProtocol context=$serverContext"
}

# Set virtual server profiles we support.  The format expected is: profiles replace-all-with { <profile1> <profile2> }.  
# To achieve this while re-using generic_add_option() we simply pass the var name with a blank option string
array set vs_profiles {
 "vs__ProfileHTTP" ""
 "vs__ProfileOneConnect" ""
}

# Save the base profile string for later use by feature__redirectToHTTPS
if { $feature__redirectToHTTPS eq "enabled"} {
  set vsprofiles_redirect $vsprofiles
}

# Client-SSL profile created by iApp
if { $clientssl == 1 } {
  set vs__ProfileClientSSL [format "%s_clientssl" $app]
  set vs_profiles(vs__ProfileClientSSL) ""
  debug "\[create_virtual\]\[client_ssl_created\] name=$vs__ProfileClientSSL"
}

# Client-SSL profile specified via vs__ProfileClientSSL
if { $clientssl == 2 } {
  set vs_profiles(vs__ProfileClientSSL) ""
  debug "\[create_virtual\]\[client_ssl_specified\] name=$vs__ProfileClientSSL"
}

# Process the vs_profiles array to build the profiles command
foreach {optionvar optioncmd} [array get vs_profiles] {
  #debug "\[create_virtual\]\[profiles\] var=$optionvar cmd=$optioncmd"
  append vsprofiles [generic_add_option "create_virtual\]\[options" [set [subst $optionvar]] $optioncmd "" 0]
}

append vsprofiles " \}"
debug "\[create_virtual\]\[profiles\] final string=$vsprofiles"

# Add the profile string to the TMSH command
append cmd $vsprofiles

# Create the virtual server
debug "\[create_virtual\]  TMSH CREATE: $cmd"
tmsh::create $cmd

# Create and additional virtual server on port 80 for feature__redirectToHTTPS
if { $feature__redirectToHTTPS eq "enabled" } {
  debug "\[create_virtual\]\[feature__redirectToHTTPS\] feature__redirectToHTTPS is enabled, creating redirect virtual server on $vs_dest_addr:80"

  set redirect_cmd [format "ltm virtual /%s/%s.app/%s_redirect destination %s:80 " $partition $app $vs__Name $vs_dest_addr]
  array set vs_redirect_options {
   "pool__mask" "mask"
   "vs__IpProtocol" "ip-protocol"
   "vs__SourceAddress" "source"
 }

  # Process the vs_options array
  foreach {optionvar optioncmd} [array get vs_redirect_options] {
    #debug "\[create_virtual\]\[options\] var=$optionvar cmd=$optioncmd"
    append redirect_cmd [generic_add_option "create_virtual\]\[feature__redirectToHTTPS\]\[options" [set [subst $optionvar]] $optioncmd "" 0]
  }

  # The HSTS spec recommends that when redirected a 301 Redirect is used, rather than a 302 like _sys_https_redirect uses
  if { $feature__securityEnableHSTS eq "enabled" } {
    debug "\[create_virtual\]\[feature__redirectToHTTPS\] feature__securityEnableHSTS is enabled, using $hstsredirectrule"
    append redirect_cmd " rules { $hstsredirectrule } "
  } else {
    append redirect_cmd " rules { /Common/_sys_https_redirect } "
  }

  append redirect_cmd $vsprofiles_redirect
  append redirect_cmd [generic_add_option "create_virtual\]\[feature__redirectToHTTPS\]\[options" $vs__ProfileHTTP "" "" 0]
  append redirect_cmd " \}"
  debug "\[create_virtual\]\[feature__redirectToHTTPS\] TMSH CREATE: $redirect_cmd"
  tmsh::create $redirect_cmd
}

# Create iCall statistics publisher
# CAVEATS: This is mode specific because $app_stats is not set unless deployment
# is driven by BIG-IQ.  To accomodate all use cases we make this mode specific:
# mode=1 (Standalone) : Look at $iapp__appStats from the presentation layer to control creation
# mode=2 (BIGIQ Cloud): Look at $app_stats set by BIG-IQ to control creation
# mode=3 (APIC)       : Look at $app_stats set by BIG-IQ to control creation
debug "\[create_stats\] mode=$mode app_stats=$app_stats iapp__appStats=$iapp__appStats"
if { (($mode == 2 || $mode == 3) && $app_stats eq "enabled") || ($mode == 1 && $iapp__appStats eq "enabled") } {
  # Create the iCall stats publisher
  # TODO: This needs to check for the presence of a HTTP profile and only add HTTP stats if that exists
  debug "\[create_stats\] creating icall stats publisher"
      # START EMBEDDED ICALL SCRIPT
  set icall_script_tmpl {
    set app APP
    set partition PART
    set aso "sys.application.service /$partition/${app}.app/$app"
          
    set virtual_path    "ltm virtual /$partition/${app}.app/VS"
    set http_path       "ltm profile http HTTP"
    set pool_path       "ltm pool /$partition/${app}.app/POOL"

    #puts "app=$app"
    #puts "partition=$partition"
    #puts "aso=$aso"
    #puts "virtual_path=$virtual_path"
    #puts "http_path=$http_path"
    #puts "pool_path=$pool_path"

    # these lists represent strings taken from "show ... field-fmt"
    set http_stats { get-reqs number-reqs post-reqs resp-5xx-cnt }
    set virtual_stats {
        clientside.bits-in clientside.bits-out clientside.cur-conns
        clientside.max-conns clientside.pkts-in clientside.pkts-out
        clientside.tot-conns status.availability-state status.enabled-state
        status.status-reason
    }
    set pool_stats {
        active-member-cnt serverside.bits-in serverside.bits-out
        serverside.cur-conns serverside.max-conns serverside.pkts-in
        serverside.pkts-out serverside.tot-conns
    }

    # loop over each type of object we want to look at, building the name
    # of the path and the stats for it as needed
    foreach type { HTYPE virtual pool } {
        # making this its own variable made the Tcl validator stop throwing
        # a warning - though it _should_ be fine to move it inline w/its use
        set path [set ${type}_path]
        set objs [tmsh::get_status $path raw]
        if { [llength $objs] == 0 } {
            puts "no object found for: $type"
            continue
        }
        set obj [lindex $objs 0]
        #puts "obj=$obj"
        foreach stat [set ${type}_stats] {
            #puts " stat=$stat"
            set value [tmsh::get_field_value $obj $stat]
            #puts " aso=$aso stat=$stat value=$value"
            # associate the iStat with the app service
            istats::set "$aso string $stat" $value
        }
    }

    # Set an additional iStat for the size of the pool, as this is not
    # stored as a stat but is nice to have when looking at pool health.
    # Do that here each run through rather than in the iApp because if
    # an external pool is used or strictness was off the size of the
    # pool can change and the iApp wouldn't run to adjust the size
    set pools [tmsh::get_config $pool_path]
    set numpools [llength $pools]
    set pool_size 0
    #puts "numpools=$numpools pool_size=$pool_size"
    if { $numpools == 1 } {
      # safe to assume only obj in list is our pool now. grab its size
      # and move along
      set pool [lindex $pools 0]
      set fdx 0
      set fields [tmsh::get_field_names nested $pool]
      set field_count [llength $fields]
      while { $fdx < $field_count } {
        set field [lindex $fields $fdx]
        #puts "field=$field"
        incr fdx
        if { $field eq "members"} {
          set pool_size [llength [tmsh::get_field_value $pool members]]
          #puts "new pool_size=$pool_size"
        }
      }
    }
    istats::set "$aso string total-member-cnt" $pool_size
    #set tmc [istats::get $aso total-member-cnt]
    #puts "tmc=$tmc"
  }; # END EMBEDDED ICALL SCRIPT

  #debug "done creating icall stats publisher icall_script_tmpl=$icall_script_tmpl"
  if { [string length $vs__ProfileHTTP] > 0 } {
    set htype "http"
  } else {
    set htype ""
  }

      # used to fill in variables within iCall script
  set script_map [list APP   $tmsh::app_name \
                       VS    $vs__Name \
                       HTTP  [format "%s" $vs__ProfileHTTP] \
                       POOL  $pool__Name \
                       PART  $partition \
                       HTYPE $htype ]

  set icall_script_src [string map $script_map $icall_script_tmpl]
  debug "\[create_stats\] icall_script_src=$icall_script_src"

  debug "\[create_stats\] TMSH CREATE publish_stats script"
  tmsh::create sys icall script publish_stats definition \{ $icall_script_src \}
  debug "\[create_stats\] TMSH CREATE iCall handler"
  tmsh::create sys icall handler periodic publish_stats interval 60 script publish_stats
}

# Call the custom_extensions proc to allow site-specific customizations
custom_extensions

if { $iapp__strictUpdates eq "disabled" } {
  debug "\[strict_updates\] disabling strict updates"
  tmsh::modify [format "sys application service /%s/%s.app/%s strict-updates disabled" $partition $app $app]
}

set runTime [expr {[clock seconds] - $startTime}]
debug "Finished app_name=$app, total run time was $runTime seconds"
            }
            macro {
            }
            presentation {
#
# This Source Code Form is subject to the terms of the Mozilla Public
# License, v. 2.0. If a copy of the MPL was not distributed with this
# file, You can obtain one at http://mozilla.org/MPL/2.0/.

section intro {
  message hello
}

section iapp {
  string strictUpdates display "large" default "enabled"
  string appStats display "medium" default "enabled"
}

section pool {
  string addr display "large" required default "172.16.0.231"
  string mask display "large" required default "255.255.255.255"
  string port display "small" required default "443"

  string Name display "xxlarge" required default "my_pool"
  string Description display "xxlarge" default "pooldescr"
  string Monitor display "large" default "/Common/http"

  choice LbMethod display "xxlarge" default "round-robin" {
    "dynamic-ratio-member",
    "dynamic-ratio-node",
    "fastest-app-response",
    "fastest-node",
    "least-connections-member",
    "least-connections-node",
    "least-sessions",
    "observed-member",
    "observed-node",
    "predictive-member",
    "predictive-node",
    "round-robin",
    "ratio-member",
    "ratio-node",
    "ratio-session",
    "ratio-least-connections-member",
    "ratio-least-connections-node",
    "weighted-least-connections-member"
  }

  string MemberDefaultPort display "small" default "80"

  table Members {
    string IPAddress display "large" required default "10.0.0.100"
    string Port display "small" required default "80"
    string ConnectionLimit display "medium" required default "0"
    string Ratio display "small" required default "1"
    choice State display "medium" default "enabled" {
      "enabled",
      "drain-disabled",
      "disabled"
    }
  }  
}

section vs {
  string Name display "xxlarge" required default "my_virtualserver"
  string Description display "xxlarge" default "vsdescr"
  string SourceAddress display "large" default "0.0.0.0/0"
  #string IpAddress display "large" required default "172.16.0.231"
  #string Mask display "large" required default "255.255.255.255"
  #string Port display "small" required default "443"

  string IpProtocol display "small" default "tcp"
  string ConnectionLimit display "medium" default "0"
  string ProfileClientProtocol display "large" default "/Common/tcp-wan-optimized"
  string ProfileServerProtocol display "large" default "/Common/tcp-lan-optimized"

  string ProfileHTTP display "large" default "/Common/http" 

  string ProfileOneConnect display "large" default "/Common/oneconnect"

  string ProfileDefaultPersist display "large" default "/Common/cookie"
  string ProfileFallbackPersist display "large" default "/Common/source_addr"

  string SNATConfig display "large" default "automap"
  string ProfileClientSSL display "large"
  string ProfileClientSSLCert display "large" default "/Common/default.crt"
  string ProfileClientSSLKey display "large" default "/Common/default.key"
  string ProfileClientSSLChain display "large" default "/Common/ca-bundle.crt"
  string ProfileClientSSLCipherString display "xxlarge" default "DEFAULT:!SSLV3"

  choice OptionSourcePort default "preserve" { "preserve", "preserve-strict", "change"}
  choice OptionConnectionMirroring default "disabled" { "disabled", "enabled"}

  string Irules display "xxlarge" default ""
}

section feature {
  choice redirectToHTTPS default "auto" { "auto", "enabled", "disabled"}
  choice securityEnableHSTS default "disabled" { "disabled", "enabled"}
}

section extensions {
  string Field1 display "xxlarge"
  string Field2 display "xxlarge" 
  string Field3 display "xxlarge"  
}

text { 
  intro "F5 Application Services Integration iApp (Community Edition)"
  intro.hello "Introduction" "Please complete the following template"

  iapp "iApp Options"
  iapp.strictUpdates "iApp: Strict Updates"
  iapp.appStats "iApp: Statistics Handler Creation"

  # These need to be in this section and named exactly for BIG-IQ to pickup the VS association for stats
  pool "Virtual Server Listener & Pool Configuration"
  pool.addr "Virtual Server: Address"
  pool.mask "Virtual Server: Mask"
  pool.port "Virtual Server: Port"

  pool.Name "Pool: Name"
  pool.Description "Pool: Description"
  pool.Monitor "Pool: Health Monitor"
  pool.LbMethod "Pool: Load Balancing Method"
  pool.MemberDefaultPort "Pool: Member Default Port"
  pool.Members "Pool: Members"
  pool.Members.IPAddress "IP:"
  pool.Members.Port "Port:"
  pool.Members.ConnectionLimit "Connection Limit:"
  pool.Members.Ratio "Ratio:"
  pool.Members.State "State:"

  vs "Virtual Server Configuration"
  vs.Name "Virtual Server: Name"
  vs.IpProtocol "Virtual Server: IP Protocol"
  vs.Description "Virtual Server: Description"
  vs.SourceAddress "Virtual Server: Source Address"
  vs.ProfileClientProtocol "Virtual Server: Client-side L4 Protocol Profile"
  vs.ProfileServerProtocol "Virtual Server: Server-side L4 Protocol Profile"
  vs.ProfileHTTP "Virtual Server: HTTP Profile"
  vs.ProfileOneConnect "Virtual Server: OneConnect Profile"
  vs.ProfileDefaultPersist "Virtual Server: Default Persistence Profile"
  vs.ProfileFallbackPersist "Virtual Server: Fallback Persistence Profile"
  vs.SNATConfig "Virtual Server: SNAT Configuration (enter SNAT pool name, 'automap' or leave blank to disable SNAT)"
  vs.ProfileClientSSL "Virtual Server: Client SSL Profile"
  vs.ProfileClientSSLCert "Virtual Server: Client SSL Certificate"
  vs.ProfileClientSSLKey "Virtual Server: Client SSL Key"
  vs.ProfileClientSSLChain "Virtual Server: Client SSL Certificate Chain"
  vs.ProfileClientSSLCipherString "Virtual Server: Client SSL Cipher String"
  vs.OptionSourcePort "Virtual Server: Source Port Behavior"
  vs.OptionConnectionMirroring "Virtual Server: Connection Mirroring"
  vs.Irules "Virtual Server: iRules (to specify multiple iRules seperate with a comma ex: irule1,irule2,irule3)"
  vs.ConnectionLimit "Virtual Server: Virtual Server Connection Limit (0=unlimited)"

  feature "L4-7 Application Functionality"
  feature.redirectToHTTPS "HTTP: Security: Create HTTP(80)->HTTPS(443) Redirect"
  feature.securityEnableHSTS "HTTP: Security: Enable HTTP Strict Transport Security (only valid if ClientSSL is configured)"

  extensions "Custom Extensions Section"
  extensions.Field1 "Extensions: Field 1"
  extensions.Field2 "Extensions: Field 2"
  extensions.Field3 "Extensions: Field 3"
}
            }
            role-acl none
            run-as none
        }
    }
    description none
    ignore-verification false
    requires-bigip-version-max none
    requires-bigip-version-min none
    requires-modules { ltm }
    signing-key none
    tmpl-checksum none
    tmpl-signature none
}
